package f_OOP2;

public class InheritanceBasic {
	public static void main(String[] args) {
		
		/*
		 
		1. 상속( ~is a : ~은 ~이다.) 예) 인간은 포유류 이다. 상하위관계 만드는것.
		  - 기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
		  - 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
		  - 새로 작성하고자 하는 클래스의 뒤에 상속받고자 하는 클래스의 이름을
		        키워드 'extends'와 함께 써주기만 하면된다.
		
			class Child extends Parent{
				.....
			}
		
		  - 부모의 멤버변수와 멤버 메서드만 생성자와 초기화블럭은 안됨
		  - 상속을 해주는 클래스를 '조상클래스', 상속을 받는 클래스를 '자손클래스'라 한다.
			: 조상클래스 - 부모클래스, 상위클래스, 기반클래스
			: 자손클래스 - 자식클래스, 하위클래스, 파생된클래스
		
		  - 자손클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
		
		2. 포함관계 ( has a : ~은 ~을 포함하고 있다.)
		  - 상속이외에 클래스를 재사용하는 또다른 방법
		  
		  
		3. toString()
		  - Object의 메서드 이다.
		  - 인스턴스의 정보를 문자열로 반환 할 목적으로 사용된다.  // 주소값을 반환하고있다.
		  - System.out.println(c.toString()); //주소를 반환하는것이 맘에 안들어서 재정의해서 사용하였다.
		  
		  
		4. 단일상속  
		  - 자바에서는 단일상속(두개이상은 불가능)
		    class TVCR extends TV,VCR{  //불가능하다
		    
		    }
		  - 위의 표현은 허용하지 않는다.
		  
		5. Object클래스 (모든 클래스의 조상클래스)  
		// equals , toString 등 모든클래스엔 필수적으로 있어야하는 메서드를 넣어놈
		  - 모든클래스의 상속계층도의 제일 위에 위치하는 조상 클래스 이다.
		  - 다른클래스로부터 상속받지 않는 모든 클래스들은 자동적으로 Object클래스를 상속 받는다.
		  
		    
		  class Tv{
		  
		  }
		   
		    생략된것들
		  
		  class Tv extends Object{
		  		Tv(){
		  			super();
		  		}
		  }
		  
		  - toString()나 equals()와 같은 메서드들은 따로 정의하지 않고 사용할 수 있는 것은 
		  Object클래스에 정의된 것들이기 때문이다.
		  
		  
		6. 오버라이딩(overriding)
		  - 조상 클래스로부터 상속받은 메서드의 내용을 재정의 하는 것.
		  - 오버라이딩이 성립하기 위한 조건(선언부가 일치해야 한다.)
		    : 메서드의 명칭이 같아야 한다.
		    : 매개변수의 개수와 타입이 같아야 한다.
		    : 반환타입이 같아야 한다.
		    : 오버라이딩 할때 접근제어자 조상클래스의 범위보다 좁게 변경할수 없다. // 넓어지는것 상관없음
		    	예외는 조상클래스의 메서드보다 많이 선언할 수 없다.
		    	인스턴스 메서드를 static메서드로 변경할 수 없다.
		    
		    오버로딩은 한클래스 내에 같은 이름의 메서드를 만들기위해서이고
		    오버라이딩은 상속받은 메서드의 내용을 재정의 하는것.
		  
		
		7. super.
		  - 조상클래스의 멤버(변수와 메서드)와 자손클래스의 멤버가 중복정의되어 있을때 서로 구별할 떄 사용.
		  - 조상멤버와 자신의 멤버를 구별하는데 사용한다는 점을 제외하고는 this와 근본적으로 같다. 
		    (this는  이 인스턴스의 라는 뜻이라 클래스 사용불가)
		  - 클래스 메서드에서는 사용될수 없고 인스턴스 멤버에만 사용 가능하다.
		
		
		8. super()
		  - this() 같은 클래스내에 다른 생성자를 호출할때 사용 // 무조건 첫줄에 써야한다.
		  - super() 부모클래스의 생성자를 호출할때 사용 // 생성자 내에서 this();가 없을때만 자동생성
		
		
		9. 제어자
		  - 클래스, 변수, 메서드 선언부에 사용된다.
		  - 접근제어자, 그외 제어자
		  - 접근제어자
		    : public, protected, default, private
		  - 그외 제어자
		    : static, final, abstract, native, .....
		  - 접근제어자를 제일 왼쪽에 두는것이 일반적이다. (바꿔도 상관은없지만)
		  
		  - static (클래스의, 공통적인 )
		    : 변수, 메서드, 초기화블럭에만 사용 가능하다.
		    : 모든 인스턴스에서 공통적으로 사용
		    	클래스명.변수명 => 인스턴스의 생성없이 사용 가능하다.
		    	클래스가 메모리에 로드될때 같이 생성된다.
		    	클래스멤버에서는 인스턴스 멤버를 사용할 수 없다.
		    	
		  - final (마지막의, 변경할 수 없는)
			: 변수에 사용시 값을 변경할수 없는 상수가 된다.
			: 메서드에 사용시 오버라이드 할 수 없는 메서드가 된다. 변경할수 없는 메서드 
			: 클래스에 사용시 변경할수 없는 클래스 . 확장도 할수가 없다 . 조상클래스가 될수 없다. 상속을 못하게 하기위해 
		  
		  - abstract (추상의, 미완성의)
		  	: 메서드와 클래스에 사용 가능하다. 메서드는 선언부만 존재하는것. 미완성된 메서드를 가지고 있으면 미완성된 클래스.
		  	
		
		10. 접근제어자 //프로젝트를 만들면 src라는 소스폴더가 생기고 그안에 패키지 그안에 클래스 생성했다.
		  - public //프로젝트 전체에서 사용가능하다.
		  	: 접근제한이 없다
		  - protected // 패키지가 같아야만 부를수 있는것 + a
		  	: 같은패키지 + 다른패키지의 자손클래스에서 접근이 가능하다. 부모것에 protected 가 있을때 
		  - default  // 무조건 같은 패키지 안에만
		    : 같은패키지 
		  - private  // 같은 클래스안에서만 부를수있다. // 부르기위해서는 따로 메서드를 만들어서 값을 받아온다.
			: 같은클래스
		
		
		11. 다형성(polymorphism)
		  - 여러 가지 형태를 가질 수 있는 능력 
		  - 한 타입의 참조변수로 여러 타입의 객체를 참조 할 수 있다.
		  - 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다. // 반대로는 불가.
		        반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참수 할수는 없다.
		
		
		12. 참조변수의 형변환
		  - 서로 상속관계에 있는 클래스에서만 형변환이 가능하다.
		  - 자손타입 -> 조상타입 (up-casting) : 형변환 생략 가능
		        조상타입 -> 자손타입 (down-casting) : 형변환 생략 불가능 
		
		
		13. instanceof 연산자
		  - 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
		  - 연산결과가  true인경우 참조변수가 검사한 타입으로 형변환이 가능하다.
		  - 클래스메서드는 클래스변수처럼 참조변수의 타입에 영향을 받는다.
		  - 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다.
		
		
		14. 매개변수의 다형성
		  - 참조변수의 다형적인 특징은 매서드의 매개변수에도 적용된다.
		
		
		15. Vector
		  - 배열을 사용할 경우 전체 크기를 한번 정하면 확장할 수 없다.
		  - 이를 vector라는 클래스를 이용하여 해결 할 수 있다.
		  - 동적으로 크기가 관리되는 객체배열이다.
		  - 크기에 따라서 계속 바낄수 있다
		  
		  Vector() : 10개의 객체를 담을 수 있는 Vector인스턴스가 생성된가. => 자동적으로 크기가 증가
		                          메서드를 통해서만 추가가능
		  add()  : 객체를 추가해준다. // 매개변수 확인   //반환타입 블린  항상 true를 돌려준다
		  remove() : Vector객체에 저장된 객체를 하나 제거한다. 뒤에서부터 제거된다.
		  --  remove(index) // 삭제된것을돌려줌
		      remove(object) // 요소가 있으면 true 없으면 false를 돌려준다. 뒤부터 삭제해준다.
		  
		  isEmpty() : Vector가 비어있는지 검사한다. 객체가 몇개들엇는지 검사할때 사용
		  get(int index) : 지정된 index번째 객체를 반환한다.
		  size() : 저장된 객체의 개수를 반환한다.
		 
		  ==> 해당 클래스의 메서드들을 스스로 공부해야한다.
		  ==> P200메서드들을 공부하시면 됩니다.
		
		
		16. 추상클래스(abstract class)
		  - 추상메서드
		    : 메서드는 선언부와 구현부로 이루어져 있다.
		    : 메서드의 선언부만 작성하고 구현부는 작성되지 않은 메서드
		    	abstract 반환타입 메서드명(매개변수..); //구현부가 없이 바로종료
		    	반환타입 메서드명(매개변수..); {초기화블럭} 
		    
		  - 추상 클래스 
		    : 추상메서드를 포함하고 있는 클래스 // 왜만드느냐?? 

		
		17. 인터페이스(interface) JDK1.7기준
		  - 일종의 추상클래스 이지만 추상메서드와 상수만을 멤버로 가진다. // 일반변수 사용불가 구현된메소드도 없다.
		  // 목차같은 역할을 해준다.
		  - 인터페이스의 작성
		    interface 인터페이스명{
		    	public static final 변수타입 변수명 = 값; // 상수
		    	(public static final) 변수타입 변수명 = 값; // 생략가능
		    	public abstract 반환타입 메서드명(매개변수....);  // 추상메서드
			}
			
			: 모든 멤벼변수는 public static final 이어야 한다. => 생략가능하다.
			: 모든 메서드는 public abstract 이어야한다. => 생략가능하다.
			
		  - 인터페이스의 상속
		    : 인터페이스는 인터페이스만 상속받을 수 있다.
		    : 클래스는 다중상속이 불가능 하다. 인터페이스는 다중상속이 가능하다. 선언부만 있기때문에 어떤걸 받아도 상관없다. 
			: 인터페이스는 클래스와 달리 Object와 같은 최상위 클래스가 없다.
			
		  - 인터페이스의 구현
		    : 자체적으로 인스턴스를 생성할 수 없다.
		    : 자신이 정의된 추상메서드의 몸통을 만들어 주는 클래스를 작성해야 한다.
		    : 클래스의 확장(extends), 인터페이스는 구현(implements).
		    : 인터페이스를 상속받아서 일부만 구현 하였다면 추상클래스가 되어야한다.
		        ~ able //할수있는이라는 뜻으로 이름을 많이 지었엇다
		        IMove // 인터페이스의 I를 적어서 관리
		  
		  - 인터페이스의 장점
		    : 개발시간을 단축할 수 있다.
		    : 표준화가 가능하다.
		    : 서로 관계가 없는 클래스들에게 관계를 맺어줄수 있다. // 같은 기능을 하고 같은형태를 갖도록 할수 있다.
		    : 독립적인 프로그래밍이 가능하다.  // 여러관리를 모두 인터페이스로 나누면 따로 일을 할수 있다.
		
		
		17. 내부클래스(inner class)
		  - 클래스 내에 선언된 클래스이다.
		  - 서로쉽게 접근할 수 있고 외부에서 볼때 불필요한 클래스를 감춤으로 복잡성을 줄일수 있다.
		  
		  - 인스턴스 클래스
		  	: 외부클래스의 인스턴스 멤버와 관련된 작업을 수행한다.
		  - static 클래스
		  	: 외부클래스의 클래스 멤버와 관련된 작업을 수행한다.
		  - 지역클래스 // 메서드안
		    : 외부클래스의 메서드나 초기화블럭 내에 선언되며, 선언영역 내에서만 사용 가능
		  - 익명클래스 //이름없는클래스
		  	: 클래스의 선언과 객체생성을 동시에 하는 이름없는 클래스(일회용)
		  
		  
		
		
		*/
		
		
		
		
	}
}
